/**
 * Grok/Llama3 Content Polisher Service
 *
 * Second-stage AI processing for cost-effective content polishing.
 * Uses Grok (xAI) or Llama3 to refine Claude-generated drafts.
 */

interface PolisherConfig {
  provider: 'grok' | 'groq-llama3' | 'ollama-llama3';
  apiKey?: string;
  apiEndpoint?: string;
  model?: string;
}

interface PolishResult {
  polishedContent: string;
  improvements: string[];
  seoSuggestions: string[];
  readabilityScore?: number;
}

export class ContentPolisher {
  private config: PolisherConfig;

  constructor(config: PolisherConfig) {
    this.config = {
      ...config,
      // Default models based on provider
      model: config.model || this.getDefaultModel(config.provider),
      apiEndpoint: config.apiEndpoint || this.getDefaultEndpoint(config.provider),
    };
  }

  private getDefaultModel(provider: string): string {
    switch (provider) {
      case 'grok':
        return 'grok-beta';
      case 'groq-llama3':
        return 'llama-3.3-70b-versatile'; // Updated model (3.1 deprecated)
      case 'ollama-llama3':
        return 'llama3.1:70b';
      default:
        return 'grok-beta';
    }
  }

  private getDefaultEndpoint(provider: string): string {
    switch (provider) {
      case 'grok':
        return 'https://api.x.ai/v1/chat/completions';
      case 'groq-llama3':
        return 'https://api.groq.com/openai/v1/chat/completions';
      case 'ollama-llama3':
        return 'http://localhost:11434/api/generate';
      default:
        return 'https://api.x.ai/v1/chat/completions';
    }
  }

  /**
   * Polish content generated by Claude
   */
  async polishContent(
    content: string,
    title: string,
    excerpt: string
  ): Promise<PolishResult> {
    const prompt = this.buildPolishingPrompt(content, title, excerpt);

    try {
      const response = await this.callAI(prompt);
      return this.parsePolishResponse(response);
    } catch (error) {
      console.error('[Polisher] Error:', error);
      // Fallback: return original content if polishing fails
      return {
        polishedContent: content,
        improvements: ['Polishing service unavailable'],
        seoSuggestions: [],
      };
    }
  }

  /**
   * Build polishing prompt
   */
  private buildPolishingPrompt(
    content: string,
    title: string,
    excerpt: string
  ): string {
    return `You are a professional blog editor polishing AgriTech content.

**Original Post**:
Title: ${title}
Excerpt: ${excerpt}

Content:
${content}

**Your Task**: Polish this blog post to improve:
1. **Grammar & Style**: Fix any grammatical errors, awkward phrasing
2. **Readability**: Improve flow, transitions, and clarity
3. **Consistency**: Ensure consistent tone and terminology
4. **SEO**: Optimize for search engines (keywords, structure)
5. **Engagement**: Make it more compelling without changing the core message

**IMPORTANT**:
- Keep the same structure (headings, lists, code blocks)
- Maintain the technical accuracy
- Don't change the author's voice drastically
- Focus on refinement, not rewriting

**Output Format**:
\`\`\`json
{
  "polishedContent": "Full polished content in markdown...",
  "improvements": ["List of improvements made"],
  "seoSuggestions": ["Additional SEO recommendations"],
  "readabilityScore": 85
}
\`\`\``;
  }

  /**
   * Call AI API based on provider
   */
  private async callAI(prompt: string): Promise<string> {
    switch (this.config.provider) {
      case 'grok':
        return this.callGrok(prompt);
      case 'groq-llama3':
        return this.callGroq(prompt);
      case 'ollama-llama3':
        return this.callOllama(prompt);
      default:
        throw new Error(`Unknown provider: ${this.config.provider}`);
    }
  }

  /**
   * Call Grok API (xAI)
   */
  private async callGrok(prompt: string): Promise<string> {
    const response = await fetch(this.config.apiEndpoint!, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${this.config.apiKey}`,
      },
      body: JSON.stringify({
        model: this.config.model,
        messages: [
          {
            role: 'system',
            content: 'You are a professional blog editor specializing in AgriTech content.',
          },
          {
            role: 'user',
            content: prompt,
          },
        ],
        temperature: 0.3, // Lower temperature for consistent edits
      }),
    });

    if (!response.ok) {
      throw new Error(`Grok API error: ${response.statusText}`);
    }

    const data = await response.json();
    return data.choices[0].message.content;
  }

  /**
   * Call Groq API (Llama3)
   */
  private async callGroq(prompt: string): Promise<string> {
    const response = await fetch(this.config.apiEndpoint!, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${this.config.apiKey}`,
      },
      body: JSON.stringify({
        model: this.config.model,
        messages: [
          {
            role: 'system',
            content: 'You are a professional blog editor specializing in AgriTech content.',
          },
          {
            role: 'user',
            content: prompt,
          },
        ],
        temperature: 0.3,
        max_tokens: 8000,
      }),
    });

    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`Groq API error: ${response.statusText} - ${errorBody}`);
    }

    const data = await response.json();
    return data.choices[0].message.content;
  }

  /**
   * Call Ollama (local Llama3)
   */
  private async callOllama(prompt: string): Promise<string> {
    const response = await fetch(this.config.apiEndpoint!, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: this.config.model,
        prompt: prompt,
        stream: false,
        options: {
          temperature: 0.3,
        },
      }),
    });

    if (!response.ok) {
      throw new Error(`Ollama error: ${response.statusText}`);
    }

    const data = await response.json();
    return data.response;
  }

  /**
   * Parse polishing response
   */
  private parsePolishResponse(response: string): PolishResult {
    try {
      // Extract JSON from markdown code block if present
      const jsonMatch = response.match(/```json\s*([\s\S]*?)```/);

      if (jsonMatch) {
        // Found JSON in code block
        try {
          const parsed = JSON.parse(jsonMatch[1]);
          return {
            polishedContent: parsed.polishedContent || response,
            improvements: parsed.improvements || [],
            seoSuggestions: parsed.seoSuggestions || [],
            readabilityScore: parsed.readabilityScore,
          };
        } catch (parseError) {
          // JSON in code block is malformed, try to extract content manually
          const contentMatch = jsonMatch[1].match(/"polishedContent":\s*"([\s\S]*?)"/);
          if (contentMatch) {
            return {
              polishedContent: contentMatch[1].replace(/\\n/g, '\n'),
              improvements: ['Polished successfully'],
              seoSuggestions: [],
            };
          }
        }
      }

      // Try to find just the markdown content (without JSON wrapper)
      const markdownMatch = response.match(/(?:polishedContent":\s*"?)?((?:^|\n)#{1,6}\s+.+[\s\S]*)/);
      if (markdownMatch) {
        return {
          polishedContent: markdownMatch[1].trim(),
          improvements: ['Content polished successfully'],
          seoSuggestions: [],
        };
      }

      // Fallback: use entire response
      throw new Error('Could not parse structured response');
    } catch (error) {
      console.error('[Polisher] Parse error:', error);
      // Fallback: use raw response as polished content
      return {
        polishedContent: response,
        improvements: ['Content returned but structure not parsed'],
        seoSuggestions: [],
      };
    }
  }

  /**
   * Quick grammar check only (faster, cheaper)
   */
  async quickCheck(content: string): Promise<string[]> {
    const prompt = `Quickly check this blog post for grammar and spelling errors. List only the errors found:

${content.substring(0, 3000)}

Return a JSON array of error descriptions: ["error 1", "error 2", ...]`;

    try {
      const response = await this.callAI(prompt);
      const errors = JSON.parse(response);
      return Array.isArray(errors) ? errors : [];
    } catch (error) {
      console.error('[Polisher] Quick check error:', error);
      return [];
    }
  }

  /**
   * Test connection to AI service
   */
  async testConnection(): Promise<boolean> {
    try {
      const response = await this.callAI('Hello! Please respond with "OK".');
      return response.toLowerCase().includes('ok');
    } catch (error) {
      console.error('[Polisher] Connection test failed:', error);
      return false;
    }
  }
}

/**
 * Factory function to create polisher based on env config
 */
export function createPolisher(): ContentPolisher | null {
  const provider = process.env.POLISHER_PROVIDER as 'grok' | 'groq-llama3' | 'ollama-llama3';

  if (!provider || process.env.POLISHER_ENABLED !== 'true') {
    return null;
  }

  const config: PolisherConfig = {
    provider,
    apiKey: process.env.POLISHER_API_KEY,
    model: process.env.POLISHER_MODEL,
  };

  return new ContentPolisher(config);
}
